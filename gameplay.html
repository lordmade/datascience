<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drone Defense: Thermal Vision</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Share Tech Mono', monospace; cursor: none; }
        canvas { display: block; }

        #ui-layer {
            position: absolute;
            top: 20px; left: 20px;
            color: #4ade80;
            pointer-events: none;
            z-index: 100;
        }

        #custom-alert {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid #ff4500;
            background: rgba(0, 0, 0, 0.9);
            color: #ff4500;
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 200;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.4);
        }

        #recoil-warning {
            position: absolute;
            bottom: 100px; left: 50%;
            transform: translateX(-50%);
            color: #ffcc00;
            font-size: 14px;
            display: none;
        }

        #health-container {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            width: 300px; height: 8px;
            border: 1px solid #4ade80;
        }
        #health-bar { width: 100%; height: 100%; background: #4ade80; transition: width 0.1s; }
        
        #controls-info {
            position: absolute;
            top: 20px; right: 20px;
            color: #4ade80;
            text-align: right;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div style="color:#ff4500">>> SIGNAL: THERMAL_ENGAGED</div>
        <div>DRONES_DESTROYED: <span id="score">0</span></div>
        <div id="status-readout">STATUS: SCANNING AIRSPACE...</div>
        <div style="color:#00ff88; margin-top:5px;">SCOPE: <span id="scope-status">ACTIVE</span></div>
    </div>
    
    <div id="controls-info">
        <div style="color:#ffcc00;">CONTROLS</div>
        <div>LEFT CLICK: FIRE</div>
        <div>RIGHT CLICK: TOGGLE SCOPE</div>
    </div>

    <div id="custom-alert">
        <h1 id="alert-title">BASE OVERRUN</h1>
        <p id="alert-msg">DEFENSE PERIMETER BREACHED</p>
        <button onclick="location.reload()" style="background:#ff4500; border:none; color:black; padding:10px 20px; font-family:inherit; cursor:pointer;">RE-DEPLOY</button>
    </div>

    <div id="recoil-warning">RE-CHAMBERING ROUND...</div>

    <div id="health-container"><div id="health-bar"></div></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let cw, ch, score = 0, drones = [];
        let mouse = { x: 0, y: 0 }, recoilY = 0;
        let health = 100, isDead = false, canFire = true;
        let breathing = 0, damageFlash = 0;
        let muzzleFlash = 0;
        let particles = [];
        let scopeActive = true;

        function resize() {
            cw = canvas.width = window.innerWidth;
            ch = canvas.height = window.innerHeight;
            mouse.x = cw / 2;
            mouse.y = ch / 2;
            if (drones.length === 0) {
                for(let i = 0; i < 3; i++) {
                    spawnDrone();
                }
            }
        }

        function spawnDrone() {
            const side = Math.random() > 0.5 ? 'left' : 'right';
            const startX = side === 'left' ? -100 : cw + 100;
            const targetX = cw * (0.2 + Math.random() * 0.6);
            const targetY = ch * (0.2 + Math.random() * 0.4);
            
            drones.push({
                x: startX,
                y: Math.random() * ch * 0.3,
                targetX: targetX,
                targetY: targetY,
                speed: 0.8 + Math.random() * 0.4,
                rotorSpeed: 0,
                timer: 0,
                readyToFire: false,
                lastShot: 0,
                size: 30 + Math.random() * 20
            });
        }

        function playSound(pitch, vol, dur) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(pitch, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        }

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        function drawDrone(drone) {
            ctx.save();
            ctx.translate(drone.x, drone.y);
            
            // Thermal signature glow
            ctx.shadowBlur = 35;
            ctx.shadowColor = "#ff4400";
            
            // Drone body - hot electronics
            const bodyGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, drone.size/2);
            bodyGrad.addColorStop(0, '#ffff66');
            bodyGrad.addColorStop(0.3, '#ff6600');
            bodyGrad.addColorStop(0.7, '#ff3300');
            bodyGrad.addColorStop(1, '#cc2200');
            
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.arc(0, 0, drone.size/2, 0, Math.PI*2);
            ctx.fill();
            
            // Camera/sensor hot spot
            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(0, 0, drone.size/4, 0, Math.PI*2);
            ctx.fill();
            
            // Rotor arms (cooler metal)
            ctx.strokeStyle = '#884400';
            ctx.lineWidth = 3;
            for(let i = 0; i < 4; i++) {
                const angle = (i * Math.PI/2) + drone.rotorSpeed;
                const armLen = drone.size * 0.8;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * armLen, Math.sin(angle) * armLen);
                ctx.stroke();
                
                // Hot motors at rotor tips
                const motorGrad = ctx.createRadialGradient(
                    Math.cos(angle) * armLen, 
                    Math.sin(angle) * armLen, 
                    0,
                    Math.cos(angle) * armLen, 
                    Math.sin(angle) * armLen, 
                    8
                );
                motorGrad.addColorStop(0, '#ffff88');
                motorGrad.addColorStop(0.5, '#ff8800');
                motorGrad.addColorStop(1, '#ff4400');
                
                ctx.fillStyle = motorGrad;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * armLen, Math.sin(angle) * armLen, 6, 0, Math.PI*2);
                ctx.fill();
                
                // Spinning rotors (motion blur effect)
                ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * armLen, Math.sin(angle) * armLen, 10, 0, Math.PI*2);
                ctx.stroke();
            }
            
            // Battery heat signature
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(-drone.size/4, -4, drone.size/2, 8);
            
            // Weapon system heat if ready to fire
            if (drone.readyToFire) {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(0, drone.size/3, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Threat indicator pulse
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, drone.size + 10, 0, Math.PI*2);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function createMuzzleFlash() {
            muzzleFlash = 1;
            for(let i=0; i<15; i++) {
                particles.push({
                    x: mouse.x + Math.sin(breathing) * 8,
                    y: mouse.y + Math.cos(breathing * 0.5) * 6,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 1,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // Gravity
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                if (p.color === 'red') {
                    ctx.fillStyle = `rgba(180, 0, 0, ${p.life / 1.5})`;
                } else if (p.color === 'orange') {
                    ctx.fillStyle = `rgba(255, 140, 0, ${p.life / 1.5})`;
                } else {
                    ctx.fillStyle = `rgba(255, ${200 * p.life}, 0, ${p.life})`;
                }
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * (p.life / 1.5), 0, Math.PI*2);
                ctx.fill();
            });
        }

        function loop() {
            if (isDead) return;

            // 1. Scene Background
            ctx.fillStyle = '#050a05';
            ctx.fillRect(0, 0, cw, ch);

            // Scope movement logic
            breathing += 0.02;
            recoilY *= 0.9;
            let sx = mouse.x + Math.sin(breathing) * 8;
            let sy = (mouse.y - recoilY) + Math.cos(breathing * 0.5) * 6;

            if (scopeActive) {
                // 2. Thermal Vision Clip
                ctx.save();
                ctx.beginPath(); 
                ctx.arc(sx, sy, 180, 0, Math.PI*2); 
                ctx.clip();
                
                // Gradient background for sky
                const bgGrad = ctx.createRadialGradient(cw/2, ch/3, 0, cw/2, ch/3, 800);
                bgGrad.addColorStop(0, '#001a33');
                bgGrad.addColorStop(0.5, '#000819');
                bgGrad.addColorStop(1, '#000011');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, cw, ch);

                // Draw drones
                drones.forEach(drone => {
                    drawDrone(drone);
                    
                    // Muzzle flash when drone shoots
                    if (Date.now() - drone.lastShot < 100) {
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = "#ffaa00";
                        ctx.fillStyle = "#ffff00";
                        ctx.beginPath();
                        ctx.arc(drone.x, drone.y + drone.size/3, 10, 0, Math.PI*2);
                        ctx.fill();
                    }
                });

                // Draw particles
                drawParticles();

                // Enhanced Crosshair
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(0,255,100,0.8)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(sx-30, sy); ctx.lineTo(sx-10, sy);
                ctx.moveTo(sx+10, sy); ctx.lineTo(sx+30, sy);
                ctx.moveTo(sx, sy-30); ctx.lineTo(sx, sy-10);
                ctx.moveTo(sx, sy+10); ctx.lineTo(sx, sy+30);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255,0,0,0.6)';
                ctx.beginPath();
                ctx.arc(sx, sy, 2, 0, Math.PI*2);
                ctx.fill();
                
                // Rangefinder circles
                ctx.strokeStyle = 'rgba(0,255,100,0.3)';
                ctx.lineWidth = 1;
                [50, 100, 150].forEach(r => {
                    ctx.beginPath();
                    ctx.arc(sx, sy, r, 0, Math.PI*2);
                    ctx.stroke();
                });
                
                ctx.restore();

                // Scope Ring
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#0a0a0a'; 
                ctx.lineWidth = 25;
                ctx.beginPath(); 
                ctx.arc(sx, sy, 190, 0, Math.PI*2); 
                ctx.stroke();
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, 178, 0, Math.PI*2);
                ctx.stroke();
                
                // Lens glare
                const glare = ctx.createRadialGradient(sx-60, sy-60, 0, sx-60, sy-60, 40);
                glare.addColorStop(0, 'rgba(255,255,255,0.1)');
                glare.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = glare;
                ctx.beginPath();
                ctx.arc(sx, sy, 180, 0, Math.PI*2);
                ctx.fill();
            } else {
                // No scope - full thermal view
                const bgGrad = ctx.createRadialGradient(cw/2, ch/3, 0, cw/2, ch/3, 800);
                bgGrad.addColorStop(0, '#001a33');
                bgGrad.addColorStop(0.5, '#000819');
                bgGrad.addColorStop(1, '#000011');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, cw, ch);

                // Draw drones
                drones.forEach(drone => {
                    drawDrone(drone);
                    
                    if (Date.now() - drone.lastShot < 100) {
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = "#ffaa00";
                        ctx.fillStyle = "#ffff00";
                        ctx.beginPath();
                        ctx.arc(drone.x, drone.y + drone.size/3, 10, 0, Math.PI*2);
                        ctx.fill();
                    }
                });

                // Draw particles
                drawParticles();

                // Simple crosshair for no-scope
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(0,255,100,0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(sx-20, sy); ctx.lineTo(sx-5, sy);
                ctx.moveTo(sx+5, sy); ctx.lineTo(sx+20, sy);
                ctx.moveTo(sx, sy-20); ctx.lineTo(sx, sy-5);
                ctx.moveTo(sx, sy+5); ctx.lineTo(sx, sy+20);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255,0,0,0.4)';
                ctx.beginPath();
                ctx.arc(sx, sy, 3, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Muzzle flash overlay
            if (muzzleFlash > 0) {
                ctx.fillStyle = `rgba(255, 200, 0, ${muzzleFlash * 0.3})`;
                ctx.fillRect(0, 0, cw, ch);
                muzzleFlash -= 0.1;
            }
            
            updateParticles();

            // 3. Drone Movement and Combat Logic
            drones.forEach((drone, idx) => {
                // Move toward target
                const dx = drone.targetX - drone.x;
                const dy = drone.targetY - drone.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 5) {
                    drone.x += (dx / dist) * drone.speed;
                    drone.y += (dy / dist) * drone.speed;
                } else {
                    drone.readyToFire = true;
                }
                
                drone.rotorSpeed += 0.1;
                drone.timer += 0.016;
                
                // Drone attacks
                if (drone.readyToFire && Date.now() - drone.lastShot > 2000) {
                    health -= 15;
                    damageFlash = 0.5;
                    playSound(100, 0.2, 0.3);
                    drone.lastShot = Date.now();
                    document.getElementById('health-bar').style.width = health + "%";
                }
            });

            // Spawn new drones periodically
            if (drones.length < 5 && Math.random() < 0.01) {
                spawnDrone();
            }

            if (damageFlash > 0) {
                ctx.fillStyle = `rgba(255,0,0,${damageFlash})`;
                ctx.fillRect(0, 0, cw, ch);
                damageFlash -= 0.03;
            }

            if (health <= 0) {
                isDead = true;
                document.getElementById('custom-alert').style.display = 'block';
            }

            requestAnimationFrame(loop);
        }

        window.addEventListener('mousedown', (e) => {
            e.preventDefault();
            
            // Right click - toggle scope
            if (e.button === 2) {
                scopeActive = !scopeActive;
                document.getElementById('scope-status').innerText = scopeActive ? 'ACTIVE' : 'DISABLED';
                playSound(200, 0.1, 0.1);
                return;
            }
            
            // Left click - shoot
            if (e.button === 0) {
                if (!canFire || isDead) return;
                if (audioCtx.state === 'suspended') audioCtx.resume();

                // Fire Logic
                playSound(300, 0.5, 0.5);
                createMuzzleFlash();
                recoilY = 150;
                canFire = false;
                document.getElementById('recoil-warning').style.display = 'block';

                // Hit Detection
                let sx = mouse.x + Math.sin(breathing) * 8;
                let sy = (mouse.y) + Math.cos(breathing * 0.5) * 6;
                
                // Check each drone
                for (let i = drones.length - 1; i >= 0; i--) {
                    const drone = drones[i];
                    const d = Math.hypot(drone.x - sx, drone.y - sy);
                    
                    if (d < drone.size) {
                        score++;
                        document.getElementById('score').innerText = score;
                        
                        // Explosion particles
                        for(let j=0; j<30; j++) {
                            particles.push({
                                x: drone.x,
                                y: drone.y,
                                vx: (Math.random() - 0.5) * 15,
                                vy: (Math.random() - 0.5) * 15,
                                life: 1.5,
                                size: Math.random() * 4 + 1,
                                color: Math.random() > 0.5 ? 'red' : 'orange'
                            });
                        }
                        
                        // Remove drone
                        drones.splice(i, 1);
                        
                        // Spawn new drone
                        setTimeout(() => spawnDrone(), 1000);
                        break;
                    }
                }

                // Recoil Recovery
                setTimeout(() => {
                    canFire = true;
                    document.getElementById('recoil-warning').style.display = 'none';
                }, 1200);
            }
        });
        
        // Prevent context menu on right click
        window.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('resize', resize);
        resize();
        loop();
    </script>
</body>
</html>
